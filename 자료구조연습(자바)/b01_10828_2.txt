package dataStructure1_dfs;
import java.io.*;
import java.util.StringTokenizer;	// 'java.util'을 import 해줘도 됨.	

public class b01_10828_2 {
 
	public static int[] stack;
	public static int size = 0;
	/*
	Static 변수와 static 메소드는 Static 메모리 영역에 존재하므로 객체가 생성되기 이전에 이미 할당이 되어 있습니다. 
	그렇기 때문에 객체의 생성없이 바로 접근(사용)할 수 있습니다.  
	*/
 
 
	public static void main(String[] args) throws IOException {
 
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));	
		StringBuilder sb = new StringBuilder();
		// BufferedReader로 입력을 받으면 라인단위로 입력을 받기에 따로 분리가 필요하다.
		// StringBuilder는 append함수를 이용하여 문자열을 더하게 해주는 함수이다.
		// 10828_1 에서는 split을 이용하여 문자열을 분리했지만, 아래처럼 StringTokenizer로 분리할 수 있다.
		StringTokenizer st;
		// 직역하면 문자열을 토큰화하다는 의미로, 토큰은 분리된 문자열이며, 스트링토크나이저 클래스는 하나의 문자열을 여러개의 토큰으로 분리하는 클래스이다.
		
		int N = Integer.parseInt(br.readLine());
 
		stack = new int[N];
		
		while (N-- > 0) {
			st = new StringTokenizer(br.readLine(), " ");	// (문자열, 구분자) 형태, (문자열, 구분자, (true/false))형태도 있다. 
															// 이는 구분자도 토큰으로 넣을지(true) 넣지않을지 결정한다.
			
			switch (st.nextToken()) {	// nextToken()은 분리된 문자열을 확인하는 함수이다.
				case "push":
					push(Integer.parseInt(st.nextToken()));	// switch 조건에서 nextToken으로 push인지 pop인지 명령어를 선택하였으므로 다음
															// nextToken은 명령어 뒤에 입력한 정수가 나오고 그 정수를 int타입으로 변환 후 
															// 아래 public state로 선언된 push 함수를 실행(push함수는 아래 참고)
					break;
					
				case "pop":
					sb.append(pop()).append('\n');	// StingBuilder sb를 통해 pop함수에서 리턴된 값과 \n을 뒤에 추가(append)한다.
					break;
					
				case "size":
					sb.append(size()).append('\n');
					break;
					
				case "empty":	
					sb.append(empty()).append('\n');
					break;
					
				case "top":
					sb.append(top()).append('\n');
					break;
			}
 
		}
		System.out.println(sb);	// 위 코드가 실행이 다 된 후 sb를 출력한다.
	}
 
	public static void push(int item) {	// push 함수는 int타입 변수를 받고 그 변수를 stack[size]변수에 담는다.
		stack[size] = item;
		size++;							// 다음에도 담기위해 size++를 해준다.
	}
	
	public static int pop() {	// pop 함수는 size=0일 때 -1값을 리턴하고 
		if(size == 0) {
			return -1;
		}
		else {	// size가 0이 아니라면
			int res = stack[size - 1];	// stack 마지막에 존재하는 값을(위 push에서 size++을 해줬기에 size-1이 마지막 int값이 있는 배열이다.) 변수에 담음
			stack[size - 1] = 0;	// 변수를 다시 0으로 초기화 시켜주고
			size--;					// size--를 해준다.
			return res;				// stack의 마지막 수를 담은 변수를 리턴해줌
		}
	}
	
	public static int size() {
		return size;	// size를 출력하는 함수
	}
	
	public static int empty() {	// stack 배열이 비었는지 안비었는지 확인하는 함수
		if(size == 0) {
			return 1;
		}
		else {
			return 0;
		}
	}
	
	public static int top() {	// stack의 마지막 원소를 출력하는 함수, 없으면 -1
		if(size == 0) {
			return -1;
		}
		else {
			return stack[size - 1];
		}
	}
	
	// 10828_01처럼 'Stack<Integer> stack = new Stack<>();' 이런식으로 스택을 선언하면 위와같은 함수를 만들지 않아도 사용가능
	// 즉 stack의 경우 10828처럼 풀면 편하다.
	
}