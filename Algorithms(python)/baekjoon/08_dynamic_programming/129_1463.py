# 이 문제는 그리디 알고리즘으로 보일 수도 있다, 그리디는 큰수로 계속 나누는 것이 먼저 1로 도달할 수 있지만
# 예를 들어 n=10일 경우 10->5->4->2->1보다 10에 먼저 1을 빼서 10->9->3->1이 더 빠르다. 즉 동적 계획법을 이용해야 한다.
# 제일 작은 수부터 미리 계산된 값을 저장해두고 필요할 떄 빼내야한다.

n=int(input())
d=[0]*(n+1)  

for i in range(2,n+1):  
    d[i]=d[i-1]+1 # 처음에 1을 빼는 경우의 수로 시작한다.
    
    if i%3==0:  
        d[i]=min(d[i],d[i//3]+1)   # 3으로 나뉠 경우 3으로 나눈 경우의 수와 위에서 구한 1을 빼는 경우의 수 중 최솟값을 선택
    if i%2==0:  
        d[i]=min(d[i],d[i//2]+1)

print(d[n]) 
